# React注意点总结

Jsx中表达式外面要加一层大括号，jsx代码的外层最好加上小括号防止分号自动插入的bug

Jsx属性

你可以使用引号来定义以字符串为值的属性

也可以使用大括号来定义以 JavaScript 表达式为值的属性

注意：因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。

例如，class 变成了 className，而 tabindex 则对应着 tabIndex.

JSX 代表 Objects
Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用
实际上jsx被转换为了一个对象

注意:
初学者很可能把元素的定义和一个内涵更广的定义“组件”给搞混了。我们将会在下一个章节当中对组件进行详细的介绍。元素事实上只是构成组件的一个部分，所以我们还是推荐你先读完这一章节的内容再往后看。

React 只会更新必要的部分

注意:
组件名称必须以大写字母开头。

例如，<div /> 表示一个DOM标签，但 <Welcome /> 表示一个组件，并且在使用该组件时你必须定义或引入它。

注意:
组件的返回值只能有一个根元素。这也是我们要用一个<div>来包裹所有<Welcome />元素的原因。

建议：尽可能多滴提取组件

你可以将组件切分为更小的组件，这没什么好担心的。

我们建议从组件自身的角度来命名props，而不是根据使用组件的上下文命名

Props的只读性

函数式组件与类式组件的优缺点对比

定义为类的组件有一些特性。局部状态就是如此：一个功能只适用于类。
使用类就允许我们使用其它特性，例如局部状态、生命周期钩子

使用setState()更新状态

构造函数是唯一能够初始化 this.state 的地方。

因为 this.props 和 this.state 可能是异步更新的，你不应该依靠它们的值来计算下一个状态。

要修复它，请使用第二种形式的 setState() 来接受一个函数而不是一个对象。 该函数将接收先前的状态作为第一个参数，将此次更新被应用时的props做为第二个参数

在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。

你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。

这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this.

值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面
元素变量

你可以使用变量来储存元素。它可以帮助你有条件的渲染组件的一部分，而输出的其他部分不会更改。

与运算符 &&

你可以通过用花括号包裹代码在 JSX 中嵌入任何表达式 ，也包括 JavaScript 的逻辑与 &&，它可以方便地条件渲染一个元素。

之所以能这样做，是因为在 JavaScript 中，true && expression 总是返回 expression，而 false && expression 总是返回 false。

因此，如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。

三目运算符

条件渲染的另一种方法是使用 JavaScript 的条件运算符 condition ? true : false。
如果条件变得过于复杂，可能就是提取组件的好时机了。


阻止组件渲染

在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。

组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。

一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key
当元素没有确定的id时，你可以使用他的序列号索引index作为key

如果列表可以重新排序，我们不建议使用索引来进行排序，因为这会导致渲染变得很慢

当你在map()方法的内部调用元素时，你最好随时记得为每一个元素加上一个独一无二的key

key会作为给React的提示，但不会传递给你的组件。如果您的组件中需要使用和key相同的值，请将其作为属性传递
如果一个map()嵌套了太多层级，那可能就是你提取出组件的一个好时机。

在React中，textarea会用value属性来代替。这样的话，表单中的textarea 非常类似于使用单行输入的表单

在React中，select标签并不使用之前的selected属性，而在根select标签上用value属性来表示选中项。这在受控组件中更为方便，因为你只需要在一个地方来更新组件。

总之，input type="text", textarea, 和 select 都十分类似 - 他们都通过传入一个value属性来实现对组件的控制。

我们首先知道props是只读的 这么一个事实

经验教训

在React应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。

状态提升比双向绑定方式要写更多的“模版代码”，但带来的好处是，你也可以更快地寻找和定位bug的工作。因为哪个组件保有状态数据，也只有它自己能够操作这些数据，发生bug的范围就被大大地减小了。此外，你也可以使用自定义逻辑来拒绝或者更改用户的输入。

如果某些数据可以由props或者state提供，那么它很有可能不应该在state中出现。举个例子，我们仅仅保存最新的编辑过的temperature和scale值，而不是同时保存 celsiusValue 和 fahrenheitValue 。另一个输入框中的值总是可以在 render() 函数中由这些保存的数据计算出来。这样我们可以根据同一个用户输入精准计算出两个需要使用的数据。
当你在开发UI界面遇到问题时，你可以使用 React 开发者工具来检查props属性，并且可以点击查看组件树，直到你找到负责目前状态更新的组件。这能让你到追踪到产生 bug 的源头。

React理念

第一步：把 UI 划分出组件层级

第二步：用 React 创建一个静态版本

第三步：定义 UI 状态的最小(但完整)表示

第四步：确定你的 State 应该位于哪里

第五步：添加反向数据流

EventEmitter 的核心就 是事件发射与事件监听器功能的封装。

事件监听器类似于addEventListener

