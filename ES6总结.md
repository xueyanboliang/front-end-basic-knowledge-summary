# ES6总结
### let 和 const
#### ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
#### 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
#### let不允许在相同作用域内，重复声明同一个变量。
#### let声明的变量只在它所在的代码块有效。
#### for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
#### let 不存在变量提升
#### 总结：let的特点： 1.形成块级作用域，同时变量也只在本作用域有效，外部也无法影响 2.不存在变量提升 3.暂存死区，即使用前必须先声明 4.不能重复声明
#### const声明一个只读的常量。一旦声明，常量的值就不能改变。
#### const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
#### const的作用域与let命令相同：只在声明所在的块级作用域内有效。
#### const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
#### const声明的常量，也与let一样不可重复声明。
#### const的本质：const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
#### 如果真的想将对象冻结，应该使用Object.freeze方法。除了将对象本身冻结，对象的属性也应该冻结。这样才能彻底冻结一个对象
#### 总结： const的特点：1.声明之后就不能在改变，声明之后必须马上赋值 2.不可重复声明 3.不存在变量提升 4.存在暂存死区 5.会形成块级作用域 6.const指的值不可改变实际上指的是地址不变，要想存的对象完全不变，必须深冻结
### 块级作用域
#### 外层作用域无法读取内层作用域的变量
#### 内层作用域可以定义外层作用域的同名变量。
#### ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
#### 在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
#### ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。也就是说块级作用域只在大括号下才成立
### ES声明变量的方法：ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。
### 顶层对象的获取
#### 方法1
var getGlobal = function () {

  if (typeof self !== 'undefined') { return self; }

  if (typeof window !== 'undefined') { return window; }

  if (typeof global !== 'undefined') { return global; }

  throw new Error('unable to locate global object');

};
#### 方法2
现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。

垫片库system.global模拟了这个提案，可以在所有环境拿到global。
### 解构赋值
#### 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
#### 如果解构不成功，变量的值就等于undefined。
#### 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
#### 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。
#### 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
#### 解构赋值允许指定默认值。如：
let [x, y = 'b'] = ['a']; // x='a', y='b'

let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
#### 对象的解构赋值
##### 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
##### 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 如：
let { foo: baz } = { foo: "aaa", bar: "bbb" };

baz // "aaa" 

foo // error: foo is not defined
##### 对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。
#### 字符串的结构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象
#### 函数参数也可以进行解构赋值
#### 圆括号问题 建议只要有可能，就不要在模式中放置圆括号。
### 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
### 解构赋值的用途：1.交换两个变量的值 2.从函数返回多个值返回出来之后进行赋值 3.函数参数的定义 4.提取json数据（很有用）
### 字符串的扩展
#### 字符串的遍历接口 ES6中字符串可以通过for of进行遍历
##### includes()：返回布尔值，表示是否找到了参数字符串。
##### repeat方法返回一个新字符串，表示将原字符串重复n次。
##### 模板字符串 写法：`${变量/表达式/函数}`
如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。

如果模板字符串中的变量没有声明，将报错。
### 数值的扩展 Number.isNaN()用来检查一个值是否为NaN。与传统的isNaN()方法的区别是传统的isNaN()是先调用Number()方法，而Number.isNaN()只对数值有效
#### Math.trunc方法用于去除一个数的小数部分，返回整数部分
### 函数的扩展
#### 函数参数默认值的指定
双重默认值

function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {

  console.log(method);

}

fetch('http://example.com')

// "GET"

定义了默认值的参数应该是函数参数的尾参数，因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
#### 函数的length属性 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
#### 函数参数作用域

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context），查找规则是本作用域找不到就到上一层作用域进行查找，一直找到全局，找不到就报undefined。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

#### 应用 
利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。如下：
function throwIfMissing() {

  throw new Error('Missing parameter');

}

function foo(mustBeProvided = throwIfMissing()) {

  return mustBeProvided;

}

foo()

// Error: Missing parameter
#### Rest参数 ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。如下： 
function add (...val) {
    let sum = 0
    for (let i = 0; i < val.length; i ++) {
        sum += val[i]
    }
    console.log(sum)
}
add (2, 5, 7)// 14
#### rest参数实际上是代替了arguments  rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。函数的length属性，不包括 rest 参数。
#### name属性 函数的name属性，返回该函数的函数名。
#### 箭头函数
如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。

如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。

由于大括号被解释为代码块（会作为代码块执行），所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。

与解构赋值结合：
const full = ({ first, last }) => first + ' ' + last;

// 等同于
function full(person) {

  return person.first + ' ' + person.last;

}

##### 箭头函数根本没有自己的this，导致内部的this就是！！外层代码块的this！！。正是因为它没有this，所以也就不能用作构造函数。
所以，箭头函数转成 ES5 的代码如下：

function foo() {

  setTimeout(() => {

    console.log('id:', this.id);

  }, 100);

}

// ES5
function foo() {

  var _this = this;


  setTimeout(function () {

    console.log('id:', _this.id);

  }, 100);

}
##### 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。
##### 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。
#### 关于箭头函数的总结：
1.箭头函数的this在声明的时候已经百分之百确定了，也不管嵌套了多少层，跟调用时所在的上下文完全无关。箭头函数其实压根没有自己的this，所以箭头函数的this就是它上一层代码块中的this=> let _this = this

2.箭头函数不能作为构造函数，因为他压根没有自己的this

3.箭头函数没有自己的arguments，所以不能使用，如果硬要找的话可以找到不是箭头函数的普通函数那一层，但可以用rest参数即...rest,rest变量

4.箭头函数不能用yield命令
#### 双冒号运算符 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。如下：
foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);
 #### 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。注意一定是！！！最后一步！！！才是尾调用！
### 对象的扩展
#### 属性的简写，如下：
function f(x, y) {

  return {x, y};

}

// 等同于

function f(x, y) {

  return {x: x, y: y};

}

f(1, 2) // Object {x: 1, y: 2}
#### 属性名表达式 用表达式作为属性名，这时要将表达式放在方括号之内。
#### Object.is() JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
除了：
+0不等于-0和NaN等于自身
#### Object.assign() Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
注意:1)同名属性的处理。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
    2)浅拷贝。Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
    3)数组的处理。 Object.assign可以用来处理数组，但是会把数组视为对象。
    4)取值函数的处理。 Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
##### 用途：
1.为对象添加属性和方法

2.浅拷贝对象

3.合并多个对象

4.为属性指定默认值

#### 可枚举属性
目前，有四个操作会忽略enumerable为false的属性。

for...in循环：只遍历对象自身的和继承的可枚举的属性。

Object.keys()：返回对象自身的所有可枚举的属性的键名。

JSON.stringify()：只串行化对象自身的可枚举的属性。

Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。   
### 属性的遍历
ES6 一共有 5 种方法可以遍历对象的属性。

（1）for...in

for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

（2）Object.keys(obj)

Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

（3）Object.getOwnPropertyNames(obj)

Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

（4）Object.getOwnPropertySymbols(obj)

Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

（5）Reflect.ownKeys(obj)

Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

首先遍历所有数值键，按照数值升序排列。

其次遍历所有字符串键，按照加入时间升序排列。

最后遍历所有 Symbol 键，按照加入时间升序排列。
#### Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。
#### super关键字表示原型对象。只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。如下：
const _proto_ {

    foo: 'hello world!'
}

Object.setPrototypeOf(obj, _proto_);

const obj = {

  foo: 'world',

  find() {
    
    console.log(this)

    return super.foo;

  }

}; 

obj.find() // "hello"
#### 上面代码中，super.foo指向原型对象proto的foo属性，但是函数中绑定的this却还是当前对象obj
#### Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
#### Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
#### Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。如下：
const obj = { foo: 'bar', baz: 42 };

Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
#### 对象的扩展运算符
const [a, ...b] = [1, 2, 3];

a // 1

b // [2, 3]
##### 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
let z = { a: 3, b: 4 };

let n = { ...z };

n // { a: 3, b: 4 }